{
  "questions": [
    {
      "question": "How does React handle reconciliation?",
      "options": [
        "By reloading the entire app",
        "By using keys and diffing virtual DOM",
        "By mutating the real DOM directly",
        "Through Redux only"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "Which is the most popular JavaScript framework?",
      "options": [
        "Angular",
        "React",
        "Svelte",
        "Vue"
      ],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Which company invented React?",
      "options": [
        "Google",
        "Apple",
        "Netflix",
        "Facebook"
      ],
      "correctOption": 3,
      "points": 10
    },
    {
      "question": "What's the fundamental building block of React apps?",
      "options": [
        "Components",
        "Blocks",
        "Elements",
        "Effects"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "What's the name of the syntax we use to describe the UI in React components?",
      "options": [
        "FBJ",
        "Babel",
        "JSX",
        "ES2015"
      ],
      "correctOption": 2,
      "points": 10
    },
    {
      "question": "How does data flow naturally in React apps?",
      "options": [
        "From parents to children",
        "From children to parents",
        "Both ways",
        "The developers decides"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "How to pass data into a child component?",
      "options": [
        "State",
        "Props",
        "PropTypes",
        "Parameters"
      ],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "When to use derived state?",
      "options": [
        "Whenever the state should not trigger a re-render",
        "Whenever the state can be synchronized with an effect",
        "Whenever the state should be accessible to all components",
        "Whenever the state can be computed from another state variable"
      ],
      "correctOption": 3,
      "points": 30
    },
    {
      "question": "What triggers a UI re-render in React?",
      "options": [
        "Running an effect",
        "Passing props",
        "Updating state",
        "Adding event listeners to DOM elements"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "When do we directly \"touch\" the DOM in React?",
      "options": [
        "When we need to listen to an event",
        "When we need to change the UI",
        "When we need to add styles",
        "Almost never"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "In what situation do we use a callback to update state?",
      "options": [
        "When updating the state will be slow",
        "When the updated state is very data-intensive",
        "When the state update should happen faster",
        "When the new state depends on the previous state"
      ],
      "correctOption": 3,
      "points": 30
    },
    {
      "question": "If we pass a function to useState, when will that function be called?",
      "options": [
        "On each re-render",
        "Each time we update the state",
        "Only on the initial render",
        "The first time we update the state"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "Which hook to use for an API request on the component's initial render?",
      "options": [
        "useState",
        "useEffect",
        "useRef",
        "useReducer"
      ],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Which variables should go into the useEffect dependency array?",
      "options": [
        "Usually none",
        "All our state variables",
        "All state and props referenced in the effect",
        "All variables needed for clean up"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "An effect will always run on the initial render.",
      "options": [
        "True",
        "It depends on the dependency array",
        "False",
        "In depends on the code in the effect"
      ],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "When will an effect run if it doesn't have a dependency array?",
      "options": [
        "Only when the component mounts",
        "Only when the component unmounts",
        "The first time the component re-renders",
        "Each time the component is re-rendered"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "What is the virtual DOM in React?",
      "options": [
        "A DOM maintained by the browser for performance",
        "A copy of the real DOM kept in memory",
        "A tool to access the DOM directly",
        "A browser extension for debugging"
      ],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "What hook is used to manage state in functional components?",
      "options": [
        "useEffect",
        "useReducer",
        "useState",
        "useContext"
      ],
      "correctOption": 2,
      "points": 10
    },
    {
      "question": "Which method is used to update state in a class component?",
      "options": [
        "setState",
        "updateState",
        "this.set",
        "changeState"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "What does JSX stand for?",
      "options": [
        "JavaScript XML",
        "Java Syntax Extension",
        "JavaScript X",
        "None of the above"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "What does useEffect allow you to do?",
      "options": [
        "Manage state",
        "Create refs",
        "Perform side effects",
        "Create context"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "Which hook is best for performance optimization?",
      "options": [
        "useRef",
        "useMemo",
        "useCallback",
        "useLayoutEffect"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "What is the default behavior of useEffect without dependencies?",
      "options": [
        "It runs only once",
        "It runs after every render",
        "It runs before the component renders",
        "It doesn't run at all"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "What is React Fiber?",
      "options": [
        "A CSS library",
        "React's new rendering engine",
        "A hook API",
        "An old React lifecycle"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What does the key prop help React identify?",
      "options": [
        "Which component to render",
        "How to uniquely identify components",
        "Which styles to apply",
        "Which hook to call"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "Which hook replaces componentDidMount in functional components?",
      "options": [
        "useRef",
        "useState",
        "useLayoutEffect",
        "useEffect"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "How do you lift state up in React?",
      "options": [
        "By passing data via props",
        "By using useContext",
        "By defining state in a shared parent",
        "By using Redux"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "Which hook helps prevent unnecessary re-renders?",
      "options": [
        "useMemo",
        "useState",
        "useEffect",
        "useRef"
      ],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "What is a controlled component in React?",
      "options": [
        "A component that controls others",
        "A component whose state is managed by React",
        "A component that never re-renders",
        "A class-based component only"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "How do you conditionally render components in React?",
      "options": [
        "Using if statements",
        "Using ternary operators",
        "Using logical &&",
        "All of the above"
      ],
      "correctOption": 3,
      "points": 10
    },
    {
      "question": "Which tool is used for routing in React apps?",
      "options": [
        "React Route",
        "React Navigator",
        "React Router",
        "React Redux"
      ],
      "correctOption": 2,
      "points": 10
    },
    {
      "question": "What is the main purpose of useImperativeHandle hook?",
      "options": [
        "To expose custom methods on refs",
        "To manage events",
        "To create animations",
        "To measure component dimensions"
      ],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "Which hook allows you to subscribe to context changes?",
      "options": [
        "useReducer",
        "useEffect",
        "useContext",
        "useCallback"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "What are React portals used for?",
      "options": [
        "To improve app performance",
        "To render children into a DOM node outside the parent hierarchy",
        "To lazy load components",
        "To handle routing"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "Why would you use useLayoutEffect over useEffect?",
      "options": [
        "To fetch API data",
        "To avoid flickering by running effects before painting",
        "To read localStorage",
        "To manage form states"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "Which hook is used to persist values between renders without causing re-renders?",
      "options": [
        "useMemo",
        "useRef",
        "useEffect",
        "useReducer"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What does lazy loading help with in React?",
      "options": [
        "It reduces build size",
        "It delays component rendering to improve load time",
        "It speeds up state updates",
        "It compresses images"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What is the significance of React.StrictMode?",
      "options": [
        "It prevents bugs from being logged",
        "It activates additional checks and warnings",
        "It enforces CSS modules",
        "It restricts global variables"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "How can you memoize a component in React?",
      "options": [
        "Using React.memo",
        "Using useState",
        "Using useRef",
        "Using useEffect"
      ],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "Which lifecycle method gets triggered after the component updates?",
      "options": [
        "componentDidMount",
        "componentWillUnmount",
        "componentDidUpdate",
        "getDerivedStateFromProps"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "What is the purpose of useTransition in React?",
      "options": [
        "To manage transitions in animations",
        "To defer non-urgent state updates",
        "To batch updates together",
        "To debounce inputs"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What problem does useId solve?",
      "options": [
        "Generating unique component keys",
        "Avoiding hydration mismatches in SSR",
        "Handling modals",
        "Tracking state changes"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "When is useDeferredValue useful?",
      "options": [
        "For avoiding memory leaks",
        "When rendering a large list that updates frequently",
        "To debounce text input",
        "To paginate API responses"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What is the primary difference between useEffect and useLayoutEffect?",
      "options": [
        "One runs on server, the other on client",
        "useLayoutEffect blocks painting until it finishes",
        "useEffect is async, useLayoutEffect is sync",
        "No difference"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What is the Concurrent Mode in React?",
      "options": [
        "A tool for debugging",
        "A mode for synchronous rendering",
        "A way to make React apps more responsive",
        "A deprecated feature"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "How can you improve performance in a React app with many re-renders?",
      "options": [
        "Using useMemo and React.memo",
        "Using class components",
        "Avoiding useEffect",
        "Using multiple contexts"
      ],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "What is the use of useDebugValue hook?",
      "options": [
        "To debug CSS issues",
        "To display custom hook values in React DevTools",
        "To debug performance issues",
        "To log errors"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What happens if you call a hook conditionally?",
      "options": [
        "Nothing happens",
        "React will throw an error",
        "Only the first hook is executed",
        "It reorders the hooks"
      ],
      "correctOption": 3,
      "points": 30
    },
    {
      "question": "What is render props pattern used for?",
      "options": [
        "To share logic between components",
        "To style components",
        "To manage global state",
        "To configure routing"
      ],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "Why should you avoid copying props into state?",
      "options": [
        "It increases performance",
        "It causes unnecessary re-renders",
        "It can cause bugs when props update",
        "It is memory intensive"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "What is a Higher-Order Component (HOC)?",
      "options": [
        "A component that uses hooks",
        "A component that returns another component",
        "A context provider",
        "A wrapper for useEffect"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What is a React key used for?",
      "options": [
        "To map arrays",
        "To help identify which items changed",
        "To store state",
        "To route between pages"
      ],
      "correctOption": 2,
      "points": 10
    },
    {
      "question": "How do you prevent form submission in React?",
      "options": [
        "Use return false",
        "Call event.preventDefault()",
        "Use stopPropagation",
        "Remove onSubmit"
      ],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "What is the purpose of key attribute in a list?",
      "options": [
        "To style list items",
        "To identify which items have changed",
        "To trigger re-renders",
        "To update props"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "When should useRef be preferred over state?",
      "options": [
        "When you need reactive updates",
        "When value changes should trigger re-render",
        "When you need a persistent value without causing re-renders",
        "When sharing data across components"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "What is a pure component?",
      "options": [
        "A component without JSX",
        "A component that doesn't re-render unnecessarily",
        "A component that uses only props",
        "A class-based component"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "Which lifecycle method is used to clean up in class components?",
      "options": [
        "componentDidMount",
        "componentWillUnmount",
        "componentDidUpdate",
        "getDerivedStateFromProps"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "What is the purpose of useReducer hook?",
      "options": [
        "To manage routing",
        "To replace useRef",
        "To manage complex state logic",
        "To fetch data"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "How do you pass props from parent to child in React?",
      "options": [
        "Using refs",
        "Using setState",
        "As arguments",
        "As attributes in JSX"
      ],
      "correctOption": 3,
      "points": 10
    },
    {
      "question": "What is the main reason for lifting state up in React?",
      "options": [
        "To increase performance",
        "To share state between components",
        "To avoid using Redux",
        "To reduce memory usage"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "How do you handle side effects in React?",
      "options": [
        "With useState",
        "With useEffect",
        "With useMemo",
        "With useCallback"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "Why is it important to add keys in list rendering?",
      "options": [
        "To speed up rendering",
        "To prevent bugs",
        "To help React track changes",
        "To apply styles"
      ],
      "correctOption": 2,
      "points": 10
    },
    {
      "question": "What is the use of useRef in functional components?",
      "options": [
        "To create state",
        "To persist values without triggering re-renders",
        "To log changes",
        "To replace useState"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "When is it best to use React.memo?",
      "options": [
        "Always",
        "When component props rarely change",
        "For routing",
        "When using context"
      ],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "What is the difference between useState and useReducer?",
      "options": [
        "useReducer doesn't re-render",
        "useState is used for complex logic",
        "useReducer is preferred for complex state transitions",
        "They are the same"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "What is lazy loading in React?",
      "options": [
        "Loading only visible components",
        "Rendering static pages",
        "Reducing state updates",
        "Caching components"
      ],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "How do you optimize rendering of a list in React?",
      "options": [
        "Using map directly",
        "Using useState",
        "Using keys and memoization",
        "Using refs"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "What happens if two sibling components have the same key?",
      "options": [
        "React throws an error",
        "Rendering is skipped",
        "Unexpected behavior can occur",
        "They will be merged"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "How do you test React components?",
      "options": [
        "With Jest and React Testing Library",
        "With Mocha only",
        "With Cypress only",
        "With manual clicks"
      ],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "What does the useCallback hook do in React?",
      "options": [
        "It returns a memoized callback function",
        "It caches the result of a function",
        "It triggers effects based on dependencies",
        "It creates a reference to a DOM element"
      ],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "What is the purpose of the useCallback hook in React?",
      "options": [
        "To memoize a component",
        "To create a new component",
        "To memoize a function",
        "To update state"
      ],
      "correctOption": 2,
      "points": 10
    },
    {
      "question": "How does useMemo improve performance in React?",
      "options": [
        "By reducing API calls",
        "By memoizing component trees",
        "By caching calculated values",
        "By batching state updates"
      ],
      "correctOption": 3,
      "points": 10
    },
    {
      "question": "Which of the following is NOT a valid React hook?",
      "options": [
        "useFetch",
        "useEffect",
        "useState",
        "useReducer"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "What is the main reason for using keys in lists?",
      "options": [
        "To increase performance",
        "To prevent duplicate items",
        "To help React identify items",
        "To style list items"
      ],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Which prop is commonly used to render dynamic content inside a component?",
      "options": [
        "style",
        "children",
        "className",
        "onClick"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "How do you conditionally apply a class in JSX?",
      "options": [
        "Using template strings",
        "Using the ternary operator",
        "Using the & operator",
        "Using JSX brackets"
      ],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "How are props different from state?",
      "options": [
        "Props are immutable",
        "Props are managed internally",
        "State is passed by parent",
        "State does not cause re-renders"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "What causes an uncontrolled input warning in React?",
      "options": [
        "Setting both value and defaultValue",
        "Leaving inputs without a name",
        "Using number inputs",
        "Binding inputs via ref"
      ],
      "correctOption": 3,
      "points": 10
    },
    {
      "question": "How can you lift state up?",
      "options": [
        "Move the state to the parent component",
        "Use props drilling",
        "Use useContext",
        "Apply global state"
      ],
      "correctOption": 2,
      "points": 10
    },
    {
      "question": "Which one describes JSX correctly?",
      "options": [
        "XML-like syntax used in React",
        "A template language for JavaScript",
        "A browser-specific syntax",
        "An HTML replacement"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "When should you use useReducer over useState?",
      "options": [
        "When dealing with form state",
        "For simple boolean flags",
        "When managing unrelated states",
        "When state logic is complex"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "What does the useImperativeHandle hook allow you to do?",
      "options": [
        "Call parent methods from a child",
        "Modify refs in child components",
        "Access hooks outside of components",
        "Manipulate props"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "What’s the result of calling setState in a useEffect loop without dependencies?",
      "options": [
        "An error is thrown",
        "Infinite re-renders",
        "Nothing happens",
        "Only runs once"
      ],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "How does React differ from traditional DOM manipulation?",
      "options": [
        "It mutates DOM directly",
        "It renders HTML faster",
        "It uses a virtual DOM",
        "It prevents re-renders"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "Which React hook can cause layout shifts if misused?",
      "options": [
        "useLayoutEffect",
        "useMemo",
        "useEffect",
        "useCallback"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "How do you make a component only render once on mount?",
      "options": [
        "useEffect with empty dependency array",
        "Using componentDidMount",
        "Using shouldComponentUpdate",
        "Disabling all props"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "How do you prevent a component from re-rendering?",
      "options": [
        "Remove all state",
        "Use React.memo",
        "Wrap in useEffect",
        "Freeze the props"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "What is the role of context in React?",
      "options": [
        "For local component state",
        "For static props",
        "For global-like state",
        "For class-based components"
      ],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "What makes useRef useful for DOM manipulation?",
      "options": [
        "It listens to DOM changes",
        "It can persist a mutable value",
        "It stores props",
        "It rerenders on change"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "How can you make a hook reusable?",
      "options": [
        "By prefixing with 'use' and abstracting logic",
        "Using useMemo",
        "By declaring in App.js",
        "By converting to class"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "What’s the main benefit of useTransition?",
      "options": [
        "It avoids rendering",
        "It adds transitions",
        "It allows concurrent rendering",
        "It debounces values"
      ],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "Which pattern is most suitable for shared form logic?",
      "options": [
        "Higher-order components",
        "Render props",
        "Custom hooks",
        "Controlled components"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "How does Suspense improve performance?",
      "options": [
        "By skipping rendering",
        "By waiting for data before rendering",
        "By hiding async data",
        "By batching updates"
      ],
      "correctOption": 3,
      "points": 30
    },
    {
      "question": "What can you use to simulate componentDidUpdate in functional components?",
      "options": [
        "useEffect with specific dependencies",
        "useMemo",
        "useRef",
        "useLayoutEffect only"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What are concurrent features useful for in React?",
      "options": [
        "To prioritize rendering",
        "To optimize bundle size",
        "To avoid re-renders",
        "To load images faster"
      ],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "Which problem does React 18 solve better?",
      "options": [
        "Flickering UIs",
        "Prop drilling",
        "Hydration mismatch",
        "Async rendering"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "Why use a fallback in Suspense?",
      "options": [
        "To preload modules",
        "To avoid hydration",
        "To render fallback UI while loading",
        "To prevent crashes"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "What is a key difference between useId and uuid libraries?",
      "options": [
        "useId is SSR safe",
        "uuid is faster",
        "uuid causes hydration issues",
        "useId is client-only"
      ],
      "correctOption": 3,
      "points": 30
    },
    {
      "question": "What does React.lazy enable?",
      "options": [
        "Component optimization",
        "Global state",
        "Code splitting",
        "Routing"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "What makes StrictMode helpful in React?",
      "options": [
        "It speeds up rendering",
        "It disables async code",
        "It highlights unsafe lifecycle methods",
        "It replaces PropTypes"
      ],
      "correctOption": 0,
      "points": 30
    }
  ]
}